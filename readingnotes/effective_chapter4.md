# 第四章 类和接口
类和接口是Java程序的核心，它们也Java语言的基本抽象单元。本章将帮助你更好的利用这些元素，设计出更加有用、健壮和灵活的类和接口。

### 第13条：使类和成员的可访问性最小
设计良好的模块和设计不好模块的区别在于：设计良好的模块**对于外部的其他模块而言，是否隐藏其内部数据和其他实现的细节**，设计良好的模块会隐藏所有的实现细节，把**它的API与它的实现清晰的隔离开来**，模块与模块之间只通过它们的API进行通信。

一个模块不需要知道另一个模块的具体的实现，这个概念被称之为信息隐藏。信息隐藏的好处：它可以有效地解除组成系统的各模块之间的耦合关系，使得这些模块可以独立的开发、测试、优化、使用、理解和修改。

#### 实现信息隐藏的原则：

- 尽可能的使每个类/成员不被外界访问。

     如果一个包级私有的顶层类/接口，只是在某一个类的内部使用到，就应该考虑它成为唯一使用它的那个类的私有嵌套类。

    >有条规则限制降低了降低方法的可访问的能力。如果方法覆盖了超类的一个方法，子类中的访问级别就不允许低于超类中的访问级别。这条规则有一张额外的情况：如果一个类实现了一个借口，那么接口中所有的类方法在这个类中也都必须声明为公有的。

- 实例域决不能是公有的
   
     如果域是非final的，或者是一个指向可变对象的final的引用，那么一旦使这个域成为公有的，就放弃了对存储在这个域中的值进行限制的能力。**包公有可变域并不是线程安全的**。
     
eg ：
错误的方式：
    
    public static final Thing[] VALUES = { ... };
如果类具有公有的静态final域或者返回这种域的访问方法，客户端就能够随意改变数组的内容。

解决这种问题的方式 ：

- 使公有数组变成私有的，并增加一个公有的不可变的列表


    private static final Thing[] PRIVATE_VALUES = { ... };
    public static final List<Thing> VALUES =
        Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
          
  或者      
 - 使数组变成私有的，并添加一个公有的方法，让它返回私有数组的一个备份
 
    
    private static final Thing[] PRIVATE_VALUSE = { ... };
    public static final Thing[] values() {
        return PRIVATE_VALUES.clone();
    }
    
    
### 第14条：在公有类中使用访问方法而非公有域    
如果类可以在它所在的包外部进行访问，对于可变类来说，应该用包含**私有域和公有访问方法**的类来替代。比如

    public class Point {
    
        private double x;
        private double y;
    
        public double getX(){
            return x;
        }
    
        public double getY(){
            return y;
        }
    
        public void setX(double x){
            this.x = x;
        }
    
        public void setY(double y){
            this.y = y;
        }
    
    }
    
    
但是如果类是包级私有的，或是私有的嵌套类，直接暴露它的数据域并没有本质的错误。


### 第15条：使可变性最小化
为了使类成为不可变，要遵循下面的五条规则：
 - 不要提供任何会修改对象的方法
 - 保证类不会被拓展
 - 使所有的域都是final的
 - 使所有域都是私有的
 - 确保对于任何可变组件的互斥访问
 
不可变对象本质上是**线程安全**的，它们不要求同步，当多个线程并发访问这样的对象时，它们不会遭到破坏。同时，没有任何线程注意其他线程对于不可变对象的影响，所以**不可变对象可以被自由的共享**，因而不可变对象也不需要进行保护性拷贝，实际上也不需要，因为每次拷贝的对象始终等于原始对象。

不可变对象的缺点是：对于每个不同的值都需要一个单独对象。特别是对于大型对象的情形，创建对象的代价可能会非常高。

除了“使类成为final的”之外，另一种方法就是：让类的所有构造器都私有/包级私有，并添加公有的静态工厂来代替公有的构造器。
eg. 

    public class Complex {
    
        private final double re;
        private final double im;
    
        private Complex(double re,double im){
           this.re = re;
           this.im = im;
        }
    
        public static Complex valueOf(double re,double im){
            return new Complex(re,im);
        }
    
    }

##### 注意
如果让不可变的类实现Serializable接口，并且它包含一个或者多个指向可变对象的域，就必须提供一个显示的readObject或者readResolve方法。

另外，坚决不要给每个get方法便携一个相应的set方法，除非有很好的理由让类变成可变的，否则就应该是不可变的。

### 第16条：复合优先于继承
继承是实现代码重用的有力手段，但是继承打破了**封装性**，子类依赖于超类中的特定的实现细节。

###第18条：接口优于抽象类

##### 接口和抽象类的区别：
 - 抽象类允许包含某些方法的实现，接口则不允许
 - 为了实现抽象类定义的类型，类必须成为抽象类的一个子类

何时使用接口：
 - 现有的类很容易被更新，以实现新的接口
 - 接口是定义mixin(混合类型)的理想选择
 
    >接口的主要作用还是**定义类型**。
    
### 第19条：接口只用于定义类型
当类实现接口时，接口就充当可以引用这个类的实例的类型。类实现了接口，就表明客户端可以对这个类的实例实施某个动作。

(注：常量接口没有实际上的意义，不推荐使用)


